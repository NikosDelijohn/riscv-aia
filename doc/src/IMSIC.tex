
%=======================================================================
\chapter{Incoming MSI Controller (IMSIC)}
\label{ch:IMSIC}
\chaptermark{IMSIC}

\textbf{%
Warning!
This draft specification is likely to change before being accepted as
standard by the {\RISCV} International Association.%
}
\bigskip

An Incoming MSI Controller (IMSIC) is an optional {\RISCV} hardware
component that is closely coupled with a hart, one IMSIC per hart.
An IMSIC receives and records incoming message-signaled interrupts
(MSIs) for a hart, and signals to the hart when there are pending and
enabled interrupts to be serviced.

An IMSIC has one or more memory-mapped registers in the machine's
address space for receiving MSIs.
Aside from those memory-mapped registers, software interacts with an
IMSIC primarily through several {\RISCV} CSRs at the attached hart.

%-----------------------------------------------------------------------
\section{Interrupt files and interrupt identities}
\label{sec:IMSIC-intrFilesAndIdents}

In a {\RISCV} system, MSIs are directed not just to a specific hart but
to a specific privilege level of a specific hart, such as machine or
supervisor level.
Furthermore, when a hart implements the hypervisor extension, an IMSIC
may optionally allow MSIs to be directed to a specific virtual hart at
virtual supervisor level (VS level).

For each privilege level and each virtual hart to which MSIs
may be directed at a hart, the hart's IMSIC contains a separate
\emph{interrupt file}.
Assuming a hart implements supervisor mode, its IMSIC has at least two
interrupt files, one for machine level and the other for supervisor
level.
When a hart also implements the hypervisor extension, its IMSIC may
have additional interrupt files for virtual harts.
The number of interrupt files an IMSIC has for virtual harts is exactly
\emph{GEILEN}, the number of supported guest external interrupts.

Each individual interrupt file consists mainly of two arrays of bits
of the same size, one array for recording MSIs that have arrived but
are not yet serviced (interrupt-pending bits), and the other array
for specifying which interrupts the hart will currently accept
(interrupt-enable bits).
Each bit position in the two arrays corresponds with a different
interrupt \emph{identity number} by which MSIs from different sources
are distinguished at an interrupt file.
Because an IMSIC is the external interrupt controller for
a hart, an interrupt file's interrupt identities become the
\emph{minor identities} for external interrupts at the attached hart.

The number of interrupt identities supported by an interrupt file
(and hence the number of active bits in each array) is one less than a
multiple of 64, and may be a minimum of 63 and a maximum of 2047.

\begin{commentary}
Platform standards may increase the minimum number of interrupt
identities that must be implemented by each interrupt file.
Platform standards for UNIX-like operating systems are likely
to require a minimum of either 127 or 255 distinct identities at
supervisor level.
\end{commentary}

When an interrupt file supports $N$ distinct interrupt identities,
valid identity numbers are between 1 and $N$ inclusive.
The identity numbers within this range are said to be implemented by
the interrupt file;
numbers outside this range are not implemented.
The number zero is never a valid interrupt identity.

IMSIC hardware does not assume any connection between the interrupt
identity numbers at one interrupt file and those at another interrupt
file.
Software is commonly expected to assign the same interrupt identity
number to different MSI sources at different interrupt files, without
coordination across interrupt files.
Thus the total number of MSI sources that can be separately
distinguished within a system is potentially the product of the number
of interrupt identities at a single interrupt file times the total
number of interrupt files in the system, over all harts.

It is not necessarily the case that all interrupt files in a system are
the same size (implement the same number of interrupt identities).
For a given hart, the interrupt files for guest external interrupts
must all be the same size, but the interrupt files at machine level
and at supervisor level may differ in size from those of guest external
interrupts, and from each other.
Likewise, the interrupt files of different harts may be different
sizes.

A platform might provide a means for software to configure the sizes
of interrupt files in some way, such as by allowing a smaller size at
machine level to be traded for a larger size at supervisor level, or
vice versa.
Any such configurability is outside the scope of this specification.
It is recommended, however, that only machine level be given the power
to change the sizes of interrupt files.

If an IMSIC contains a supervisor-level interrupt file and software at
the attached hart enables \mbox{S-mode} that was previously disabled
(e.g. by changing bit~S of CSR \z{misa} from zero to one), all state
of the supervisor-level interrupt file is valid and consistent but
otherwise {\unspecified}.
Likewise, if an IMSIC contains guest interrupt files and software at
the attached hart enables the hypervisor extension that was previously
disabled (e.g. by changing bit~H of \z{misa} from zero to one), all
state of the IMSIC's guest interrupt files is valid and consistent but
otherwise {\unspecified}.

%-----------------------------------------------------------------------
\section{MSI encoding}
\label{sec:MSIEncoding}

Established standards (in particular, for PCI and PCI Express) dictate
that an individual message-signaled interrupt (MSI) from a device takes
the form of a naturally aligned \mbox{32-bit} write by the device,
with the address and value both configured at the device (or device
controller) by software.
Depending on the versions of the standards to which a device or
controller conforms, the address might be restricted to the lower
\mbox{4-GiB} (\mbox{32-bit}) range, and the value written might be
limited to a \mbox{16-bit} range, with the upper 16~bits always being
zeros.

When {\RISCV} harts have IMSICs, an MSI from a device is normally sent
directly to an individual hart that was selected by software to handle
the interrupt (presumably based on some interrupt affinity policy).
An MSI is directed to a specific privilege level, or to a specific
virtual hart, via the corresponding interrupt file that exists in the
receiving hart's IMSIC.
The MSI write address is the physical address of a particular word-size
register that is physically connected to the target interrupt file.
The MSI write data is simply the identity number of the interrupt to
be made pending in that interrupt file (becoming eventually the minor
identity for an external interrupt to the attached hart).

By configuring an MSI's address and data at a device, system software
fully controls:
(a)~which hart receives a particular device interrupt,
(b)~the target privilege level or virtual hart, and
(c)~the identity number that represents the MSI in the target interrupt
file.
Elements a and~b are determined by which interrupt file is targeted by
the MSI address, while element~c is communicated by the MSI data.

\begin{commentary}
As the maximum interrupt identity number an IMSIC can support is 2047,
a \mbox{16-bit} limit on MSI data values presents no problem.
\end{commentary}

When the hypervisor extension is implemented and a device is being
managed directly by a guest operating system, MSI addresses from the
device are initially guest physical addresses, as they are configured
at the device by the guest OS.
These guest addresses must be translated by an I/O MMU, which gets
configured by the hypervisor to redirect those MSIs to the interrupt
files for the correct guest external interrupts.
For more on this topic, see Chapter~\ref{ch:IOMMU}.

%-----------------------------------------------------------------------
\section{Interrupt priorities}

Within a single interrupt file, interrupt priorities are determined
directly from interrupt identity numbers.
Lower identity numbers have higher priority.

\begin{commentary}
Because MSIs give software complete control over the assignment of
identity numbers in an interrupt file, software is free to select
identity numbers that reflect the relative priorities desired for
interrupts.

It is true that software could adjust interrupt priorities more
dynamically if interrupt files included an array of priority numbers to
assign to each interrupt identity.
However, we believe that such additional flexibility would not be
utilized often enough to justify the extra hardware expense.
In fact, for many systems currently employing MSIs, it is common
practice for software to ignore interrupt priorities entirely and act
as though all interrupts had equal priority.
\end{commentary}

\begin{commentary}
An interrupt file's lowest identity numbers have been given the
highest priorities, not the reverse order, because it is only for
the highest-priority interrupts that priority order may need to be
carefully managed, yet it is the low-numbered identities, 1~through 63
(or perhaps 1 through 255), that are guaranteed to exist across all
systems.
Consider, for example, that an interrupt file's highest-priority
interrupt---presumably the most time-critical---is always identity
number~1.
If priority order were reversed, the highest-priority interrupt would
have different identity numbers on different machines, depending on how
many identities are implemented by interrupt files.
The ability for software to assign fixed identity numbers to the
highest-priority interrupts was considered worth any discomfort that
may be felt from interrupt priorities being the reverse of the natural
number order.
\end{commentary}

%-----------------------------------------------------------------------
\section{Memory region for an interrupt file}
\label{sec:IMSIC-memRegion}

Each interrupt file in an IMSIC has one or two memory-mapped
\mbox{32-bit} registers for receiving MSI writes.
These memory-mapped registers are located within a naturally aligned
\mbox{4-KiB} region (a page) of physical address space that exists for
the interrupt file, i.e., one page per interrupt file.

The layout of an interupt-file's memory region is:\nopagebreak
\begin{displayLinesTable}[l@{\quad}l@{\qquad}l]
offset    & \ size  & register name \\
\noalign{\medskip}
\z{0x000} & 4 bytes & \z{seteipnum\_le} \\
\z{0x004} & 4 bytes & \z{seteipnum\_be} \\
\end{displayLinesTable}
All other bytes in an interrupt file's 4-KiB memory region are reserved
and must be implemented as read-only zeros.

Only naturally aligned \mbox{32-bit} simple reads and writes are
supported within an interrupt file's memory region.
Writes to read-only bytes are ignored.
For other forms of accesses (other sizes, misaligned accesses, or
AMOs), an IMSIC implementation should preferably report an access fault
or bus error but must otherwise ignore the access.

If $i$ is an implemented interrupt identity number, writing value~$i$
in little-endian byte order to \z{seteipnum\_le} (Set External
Interrupt-Pending bit by Number, Little-Endian) causes the pending bit
for interrupt~$i$ to be set to one.
A write to \z{seteipnum\_le} is ignored if the value written is not an
implemented interrupt identity number in little-endian byte order.

For systems that support big-endian byte order, if $i$ is an
implemented interrupt identity number, writing value~$i$ in big-endian
byte order to \z{seteipnum\_be} (Set External Interrupt-Pending bit by
Number, Big-Endian) causes the pending bit for interrupt~$i$ to be set
to one.
A write to \z{seteipnum\_be} is ignored if the value written is not an
implemented interrupt identity number in big-endian byte order.
Systems that support only little-endian byte order may choose to ignore
all writes to \z{seteipnum\_be}.

In most systems, \z{seteipnum\_le} is the write port for MSIs directed
to this interrupt file.
For systems built mainly for big-endian byte order, \z{seteipnum\_be}
may serve as the write port for MSIs directed to this interrupt file
from some devices.

A read of \z{seteipnum\_le} or \z{seteipnum\_be} returns zero in all
cases.

Stores by a hart to an interrupt file's memory-mapped registers
may be arbitrarily delayed before appearing in the appropriate
interrupt-pending bits.
Whether, after accounting for these delays, such writes always
remain in the same order they were executed by the hart is
implementation-defined (or possibly platform-defined).

\begin{commentary}
It is an open question whether stores from a hart to an interrupt file
should, in all systems, be required to remain always in the same order
as executed by the hart.
\end{commentary}

%-----------------------------------------------------------------------
\section{CSRs for external interrupts via an IMSIC}

Software accesses a hart's IMSIC primarily through the CSRs introduced
in Chapter~\ref{ch:CSRs}.
There is a separate set of CSRs for each implemented privilege level
that can receive interrupts.
The machine-level CSRs interact with the IMSIC's machine-level
interrupt file, while, if supervisor mode is implemented, the
supervisor-level CSRs interact with the IMSIC's supervisor-level
interrupt file.
When an IMSIC has guest interrupt files, the VS CSRs interact with a
single guest interrupt file, selected by the VGEIN field of CSR
\z{hstatus}.

For machine level, the relevant CSRs are:\nopagebreak
\begin{displayLinesTable}[l@{\qquad}l@{\qquad}l]
\z{miselect} & \z{mseteipnum} & \z{mclaimei} \\
\z{mireg}    & \z{mclreipnum} \\
             & \z{mseteienum} \\
             & \z{mclreienum} \\
\end{displayLinesTable}

When supervisor mode is implemented, the set of supervisor-level CSRs
matches those of machine level:
\begin{displayLinesTable}[l@{\qquad}l@{\qquad}l]
\z{siselect} & \z{sseteipnum} & \z{sclaimei} \\
\z{sireg}    & \z{sclreipnum} \\
             & \z{sseteienum} \\
             & \z{sclreienum} \\
\end{displayLinesTable}

And when the hypervisor extension is implemented, there is a
corresponding set of VS CSRs for all registers except \z{sclaimei}:
\begin{displayLinesTable}[l@{\qquad}l]
\z{vsiselect} & \z{vsseteipnum} \\
\z{vsireg}    & \z{vsclreipnum} \\
              & \z{vsseteienum} \\
              & \z{vsclreienum} \\
\end{displayLinesTable}

As explained in Chapter~\ref{ch:CSRs}, registers \z{miselect} and
\z{mireg} provide indirect access to additional machine-level
registers.
Likewise for supervisor-level \z{siselect} and \z{sireg}, and VS-level
\z{vsiselect} and \z{vsireg}.
In each case, a value of the \emph{\texttt{*iselect} CSR}
(\z{miselect}, \z{siselect}, or \z{vsiselect}) in the range
\z{0x70}--\z{0xFF} selects a register of the corresponding IMSIC
interrupt file, either the machine-level interrupt file (\z{miselect}),
the supervisor-level interrupt file (\z{siselect}), or a guest
interrupt file (\z{vsiselect}).

Interrupt files at each level act identically.
For a given privilege level, values of the \z{*iselect} CSR in the
range \z{0x70}--\z{0xFF} select these registers of the corresponding
interrupt file:
\begin{displayLinesTable}[c@{\quad}l]
\z{0x70} & \z{eidelivery} \\
\z{0x72} & \z{eithreshold} \\
\z{0x76} & \z{topei} \\
\z{0x80} & \z{eip0} \\
\z{0x81} & \z{eip1} \\
\dots    & \ \dots \\
\z{0xBF} & \z{eip63} \\
\z{0xC0} & \z{eie0} \\
\z{0xC1} & \z{eie1} \\
\dots    & \ \dots \\
\z{0xFF} & \z{eie63} \\
\end{displayLinesTable}

Register numbers \z{0x71}, \z{0x73}--\z{0x75}, and \z{0x77}--\z{0x7F}
are reserved.
When a \z{*iselect} CSR has one of these values, reads from the
matching \emph{\texttt{*ireg} CSR} (\z{mireg}, \z{sireg}, or
\z{vsireg}) return zero, and writes to the \z{*ireg} CSR are ignored.
(For \z{vsiselect} and \z{vsireg}, all accesses depend on
\z{hstatus}.VGEIN being the valid number of a guest interrupt file.)

Registers \z{eip0} through \z{eip63} contain the pending bits for
all implemented interrupt identities, and are collectively called the
\emph{\texttt{eip} array}.
Registers \z{eie0} through \z{eie63} contain the enable bits for
the same interrupt identities, and are collectively called the
\emph{\texttt{eie} array}.

The indirectly accessed interrupt-file registers, and the other CSRs
that directly interact with external interrupts (\z{mseteipnum},
\z{mclreipnum}, etc.), are all documented in more detail in the next
two sections.

%-----------------------------------------------------------------------
\section{Indirectly accessed interrupt-file registers}

This section describes the registers of an interrupt file that
are accessed indirectly through a \z{*iselect} CSR (\z{miselect},
\z{siselect}, or \z{vsiselect}) and its partner \z{*ireg} CSR
(\z{mireg}, \z{sireg}, or \z{vsireg}).

For each interrupt file, the width of all indirectly accessed registers
is the width of the \z{*ireg} CSR used to access those registers,
either MXLEN, SXLEN, or VSXLEN.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{External interrupt delivery enable register (\zSafe{eidelivery})}
\label{sec:IMSIC-reg-eidelivery}

\z{eidelivery} is a {\WARL} register that controls whether interrupts
from this interrupt file are delivered from the IMSIC to the attached
hart so they appear as a pending external interrupt in the hart's
\z{mip} or \z{hgeip} CSR.
Register \z{eidelivery} may optionally also support the direct delivery
of interrupts from a PLIC (Platform-Level Interrupt Controller) to the
attached hart.
Three possible values are currently defined for \z{eidelivery}:
\begin{displayLinesTable}[r@{\ }l]
0              & = Interrupt delivery is disabled \\
1              & = Interrupt delivery from the interrupt file is enabled \\
\z{0x40000000} & = Interrupt delivery from a PLIC is enabled (optional)\\
\end{displayLinesTable}

If \z{eidelivery} supports value \z{0x40000000}, then a specific PLIC
in the system may act as an alternate external interrupt controller for
the attached hart at the same privilege level as this interrupt file.
When \z{eidelivery} is \z{0x40000000}, the interrupt file functions the
same as though \z{eidelivery} is~0, and the PLIC replaces the interrupt
file in supplying pending external interrupts at this privilege level
at the hart.

Reset initializes \z{eidelivery} to \z{0x40000000} if that value is
supported;
otherwise, \z{eidelivery} has an {\unspecified} valid value (0~or~1)
after reset.

\begin{commentary}
\z{eidelivery} value \z{0x40000000} supports system software that is
oblivious to IMSICs and assumes instead that the external interrupt
controller is a PLIC.
Such software may exist either because it predates the existence of
IMSICs or because bypassing IMSICs is believed to reduce programming
effort.
\end{commentary}

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{External interrupt enable threshold register (\zSafe{eithreshold})}

\z{eithreshold} is a {\WLRL} register that determines the minimum
interrupt priority (maximum interrupt identity number) allowing an
interrupt to be signaled from this interrupt file to the attached hart.
If $N$ is the maximum implemented interrupt identity number for this
interrupt file, \z{eithreshold} must be capable of holding all values
between 0 and~$N$, inclusive.

When \z{eithreshold} is a nonzero value $P$, interrupt identities $P$
and higher do not contribute to signaling interrupts, as though those
identities were not enabled, regardless of the settings of their
corresponding interrupt-enable bits in the \z{eie} array.
When \z{eithreshold} is zero, all enabled interrupt identities
contribute to signaling interrupts from the interrupt file.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Top external interrupt register (\zSafe{topei})}

\z{topei} is a read-only register whose value indicates the current
highest-priority pending-and-enabled interrupt that also exceeds the
priority threshold specified by \z{eithreshold}, if not zero.
Interrupts with lower identity numbers have higher priorities.

A read of \z{topei} returns zero either if no interrupt is both
pending in the \z{eip} array and enabled in the \z{eie} array, or if
\z{eithreshold} is not zero and no pending-and-enabled interrupt has an
identity number less than the value of \z{eithreshold}.
Otherwise, the value returned from a read of \z{topei} has this format:
\begin{displayLinesTable}[l@{\quad}l]
bits 26:16 & Interrupt identity \\
bits 10:0  & Interrupt priority (same as identity) \\
\end{displayLinesTable}
All other bit positions are zeros.

The interrupt identity reported in \z{topei} is the minor identity for
an external interrupt at the attached hart.

\begin{commentary}
The redundancy in the value read from \z{topei} is consistent with the
Advanced PLIC, which returns both an interrupt identity number and its
priority in the same format as above, but with the two components being
independent of one another.
\end{commentary}

Writes to \z{topei} are ignored.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{External interrupt-pending registers (\zSafe{eip0}--\zSafe{eip63})}

When the interrupt file's registers are 32~bits (as determined by
the XLEN for the corresponding privilege level), register \z{eip}$k$
contains the pending bits for interrupts with identity numbers
$k\times\mbox{32}$ through ${k\times\mbox{32} + \mbox{31}}$.
For an implemented interrupt identity $i$ within that range, the
pending bit for interrupt~$i$ is bit $(i\bmod\mbox{32})$ of \z{eip}$k$.

When the interrupt file's registers are 64~bits, the odd-numbered
registers \z{eip1}, \z{eip3}, \dots \z{eip63} do not exist.
In that case, if the \z{*iselect} CSR is an odd value in the range
\z{0x81}--\z{0xBF}, an attempt to access the matching \z{*ireg} CSR
raises an illegal instruction exception, unless done in VS-mode, in
which case it raises a virtual instruction exception.
For even~$k$, register \z{eip}$k$ contains the pending bits
for interrupts with identity numbers $k\times\mbox{32}$ through
${k\times\mbox{32} + \mbox{63}}$.
For an implemented interrupt identity~$i$ within that range, the
pending bit for interrupt~$i$ is bit $(i\bmod\mbox{64})$ of \z{eip}$k$.

Bit positions in a valid \z{eip}$k$ register that don't correspond
to a supported interrupt identity (such as bit~0 of \z{eip0}) are
read-only zeros.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{External interrupt-enable registers (\zSafe{eie0}--\zSafe{eie63})}

When the interrupt file's registers are 32~bits (as determined by
the XLEN for the corresponding privilege level), register \z{eie}$k$
contains the enable bits for interrupts with identity numbers
$k\times\mbox{32}$ through ${k\times\mbox{32} + \mbox{31}}$.
For an implemented interrupt identity $i$ within that range, the enable
bit for interrupt~$i$ is bit $(i\bmod\mbox{32})$ of \z{eie}$k$.

When the interrupt file's registers are 64~bits, the odd-numbered
registers \z{eie1}, \z{eie3}, \dots \z{eie63} do not exist.
In that case, if the \z{*iselect} CSR is an odd value in the range
\z{0xC1}--\z{0xFF}, an attempt to access the matching \z{*ireg} CSR
raises an illegal instruction exception, unless done in VS-mode, in
which case it raises a virtual instruction exception.
For even~$k$, register \z{eie}$k$ contains the enable bits for
interrupts with identity numbers $k\times\mbox{32}$ through
${k\times\mbox{32} + \mbox{63}}$.
For an implemented interrupt identity~$i$ within that range, the enable
bit for interrupt~$i$ is bit $(i\bmod\mbox{64})$ of \z{eie}$k$.

Bit positions in a valid \z{eie}$k$ register that don't correspond
to a supported interrupt identity (such as bit~0 of \z{eie0}) are
read-only zeros.

%-----------------------------------------------------------------------
\section{CSRs directly affecting an interrupt file}

Several new machine-level CSRs interact directly with an IMSIC's
machine-level interrupt file:  \z{mseteipnum}, \z{mclreipnum},
\z{mseteienum}, \z{mclreienum}, and \z{mclaimei}.
If supervisor mode is implemented, there are several matching
supervisor CSRs that likewise interact with the supervisor-level
interrupt file:  \z{sseteipnum}, \z{sclreipnum}, \z{sseteienum},
\z{sclreienum}, and \z{sclaimei}.
And if the hypervisor extension is implemented and field VGEIN of
\z{hstatus} is the number of an implemented guest interrupt file,
several VS CSRs interact with the chosen guest interrupt file:
\z{vsseteipnum}, \z{vsclreipnum}, \z{vsseteienum}, and \z{vsclreienum}.
These CSRs are documented by function below:

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{%
Set/clear external interrupt-pending bit by number
(\zSafe{*seteipnum} and \zSafe{*clreipnum})%
}

If $i$ is an implemented interrupt identity number in the respective
interrupt file, writing value $i$ to a \emph{\texttt{*seteipnum} CSR}
(\z{mseteipnum}, \z{sseteipnum}, or \z{vsseteipnum}) causes the pending
bit for interrupt~$i$ to be set to one in the interrupt file, while
writing $i$ to a \emph{\texttt{*clreipnum} CSR} (\z{mclreipnum},
\z{sclreipnum}, or \z{vsclreipnum}) causes the pending bit for
interrupt~$i$ to be cleared in the interrupt file.
A write to a \z{*seteipnum} or \z{*clreipnum} CSR is ignored if the
value written is not an implemented interrupt identity number for the
respective interrupt file.

A read of a \z{*seteipnum} or \z{*clreipnum} CSR always returns zero.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{%
Set/clear external interrupt-enable bit by number
(\zSafe{*seteienum} and \zSafe{*clreienum})%
}

If $i$ is an implemented interrupt identity number in the respective
interrupt file, writing value $i$ to a \emph{\texttt{*seteienum} CSR}
(\z{mseteienum}, \z{sseteienum}, or \z{vsseteienum}) causes the enable
bit for interrupt~$i$ to be set to one in the interrupt file, while
writing $i$ to a \emph{\texttt{*clreienum} CSR} (\z{mclreienum},
\z{sclreienum}, or \z{vsclreienum}) causes the enable bit for
interrupt~$i$ to be cleared in the interrupt file.
A write to a \z{*seteienum} or \z{*clreienum} CSR is ignored if the
value written is not an implemented interrupt identity number for the
respective interrupt file.

A read of a \z{*seteienum} or \z{*clreienum} CSR always returns zero.

%- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
\subsection{Claim top external interrupt (\zSafe{*claimei})}

The \emph{\texttt{*claimei} CSRs}, \z{mclaimei} and \z{sclaimei}, are
read-only.

A read from \z{mclaimei} or \z{sclaimei} returns the same value as the
\z{topei} register of the respective interrupt file.
When this value is not zero, a read from \z{mclaimei} or \z{sclaimei}
has the simultaneous side effect of clearing the pending bit for the
reported interrupt identity in the interrupt file.

Although there is no VS CSR \z{vsclaimei}, if field VGEIN of
\z{hstatus} is the number of an implemented guest interrupt file,
reading \z{sclaimei} in \mbox{VS-mode} of course returns the same value
as the \z{topei} register of the selected guest interrupt file and,
if this value is not zero, clears the pending bit for the reported
interrupt identity in that interrupt file.

%-----------------------------------------------------------------------
\section{Interrupt delivery and handling}

An IMSIC's interrupt files supply \emph{external interrupt} signals to
the attached hart, one interrupt signal per interrupt file.
The interrupt signal from a machine-level interrupt file appears as bit
MEIP in CSR \z{mip}, and the interrupt signal from a supervisor-level
interrupt file appears as bit SEIP in \z{mip} and \z{sip}.
Interrupt signals from any guest interrupt files appear as the active
bits in hypervisor CSR \z{hgeip}.

When interrupt delivery is disabled by an interrupt file's
\z{eidelivery} register (\z{eidelivery} =~0), the interrupt signal from
the interrupt file is held de-asserted (false).
When interrupt delivery from the interrupt file is enabled
(\z{eidelivery} =~1), the interrupt signal from the interrupt file
is asserted if and only if reading register \z{topei} would return a
nonzero value.

A trap handler solely for external interrupts via an IMSIC could be
written roughly as follows:
\begin{displayLinesTable}
save processor registers \\
\z{i = }read CSR \z{mclaimei} or \z{sclaimei} \\
\z{i = i>>16} \\
call the interrupt handler for external interrupt \z{i} (minor identity) \\
restore processor registers \\
return from trap \\
\end{displayLinesTable}

